@typeparam T
@typeparam TResponse
@inherits AppComponentBase
@using ServiceStack.Html;

<form class="space-y-8 divide-y divide-gray-200">
    <CascadingValue Value=@errorStatus>
        <div>
            <div class="pt-8">
                <div class="mt-6 grid grid-cols-1 gap-y-6 gap-x-4 sm:grid-cols-6">
                    @if (Model != null && !Model.IsEmpty())
                    {
                        @foreach (var prop in getFormOperationType().Request.Properties)
                        {
                            @if (prop.IsPrimaryKey == true)
                                continue;
                            @if (prop.Input != null)
                            {
                                prop.Input.Id = prop.Name;
                                if (prop.Input.Type == "textarea")
                                {
                                    <div class="sm:col-span-6">
                                        <DynamicInput Input="prop.Input" Model="@Model" rows="10" class="shadow-sm block w-full sm:text-sm rounded-md text-gray-900 focus:ring-indigo-500 focus:border-indigo-500 border-gray-300 shadow-sm block w-full focus:ring-blue-500 focus:border-blue-500 sm:text-sm border border-gray-300 rounded-md" />
                                    </div>
                                }
                                else
                                {
                                    <div class="sm:col-span-3">
                                        <DynamicInput Input="prop.Input" Model="@Model" />
                                    </div>
                                }
                            }
                            else
                            {
                                var inputInfo = generateDefaultInputInfo(prop);

                                <div class="sm:col-span-3">
                                    <DynamicInput Input="inputInfo" Model="@Model" />
                                </div>

                            }
                        }
                    }
                </div>
            </div>
        </div>
        <div class="pt-5">
            <div class="flex justify-end">
                <button type="button" @onclick="Cancel" class="bg-white py-2 px-4 border border-gray-300 rounded-md shadow-sm text-sm font-medium text-gray-700 hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500">Cancel</button>
                <button type="button" @onclick="Save" class="ml-3 inline-flex justify-center py-2 px-4 border border-transparent shadow-sm text-sm font-medium rounded-md text-white bg-indigo-600 hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500">Save</button>
            </div>
        </div>
    </CascadingValue>
</form>

@code {
    Dictionary<string, object> Model { get; set; } = new();

    ResponseStatus? errorStatus;

    [Parameter]
    public T Request { get; set; }

    [Parameter]
    public EventCallback<TResponse> OnDone { get; set; }

    [Parameter]
    public EventCallback<T> OnSave { get; set; }

    [Parameter]
    public EventCallback OnCancel { get; set; }

    [CascadingParameter]
    AppMetadata AppMetadata { get; set; }

    ApiUiInfo uiInfo;
    bool requestInProgress = false;

    async Task Save(MouseEventArgs e)
    {
        Request = Model.FromObjectDictionary<T>();
        await OnSave.InvokeAsync(Request);
        requestInProgress = true;
        var api = await ApiAsync((IReturn<TResponse>)Request);
        requestInProgress = false;
        if (api.Succeeded)
        {
            await OnDone.InvokeAsync(api.Response);
        }
        else
        {
            errorStatus = api.Error;
        }
    }

    async Task Cancel(MouseEventArgs e)
    {
        await OnCancel.InvokeAsync();
    }

    protected override async Task OnInitializedAsync()
    {
        if (!typeof(T).GetInterfaces().Contains(typeof(IReturn)))
            throw new Exception("Specified data type does not implement IReturn interface.");
        syncModel();
    }

    protected override Task OnParametersSetAsync()
    {
        syncModel();
        return base.OnParametersSetAsync();
    }

    void syncModel()
    {
        if (requestInProgress == false)
            Model = Request.ToObjectDictionary();
    }

    MetadataOperationType getFormOperationType()
    {
        var operation = AppMetadata.Api.Operations.FirstOrDefault(x => x != null && x.Request != null && x.Request.Name == typeof(T).Name);
        if (operation == null)
            throw new Exception($"Failed to resolve request DTO of type {typeof(T).FullName}");
        return operation;
    }

    MetadataType getMetadataType(string typeName)
    {
        var typeMetadata = AppMetadata.Api.Types.FirstOrDefault(x => x.Name == typeName);
        if (typeMetadata == null)
            throw new Exception($"Type '{typeName}' not found.");
        return typeMetadata;
    }

    InputInfo generateDefaultInputInfo(MetadataPropertyType propType)
    {
        if (propType.Type == null)
            return new InputInfo(propType.Name, "text");

        if (typeToInputTypeMapping.ContainsKey(propType.Type))
            return new InputInfo(propType.Name, typeToInputTypeMapping[propType.Type]);
        else if (typesMap.ContainsKey(propType.Type))
            return new InputInfo(propType.Name, typeToInputTypeMapping[typesMap[propType.Type]]);
        else if (propType.IsEnum == true)
        {
            var typeMetadata = getMetadataType(propType.Type);
            return new InputInfo(propType.Name, "select")
                {
                    AllowableValues = typeMetadata.EnumNames.ToArray()
                };
        }
        else
            return new InputInfo(propType.Name, "text");
    }

    readonly Dictionary<string, string> typeToInputTypeMapping = new()
        {
            { "bool", "checkbox" },

            { "DateTime", "date" },
            { "DateTimeOffset", "date" },
            { "DateOnly", "date" },

            { "TimeSpan", "time" },
            { "TimeOnly", "time" },

            { "short", "number" },
            { "int", "number" },
            { "long", "number" },
            { "ushort", "number" },
            { "uint", "number" },
            { "ulong", "number" },
            { "float", "number" },
            { "double", "number" },
            { "decimal", "number" },
            { "string", "text" },
            { "Guid", "text" },
            { "Uri", "text" }
        };

    readonly Dictionary<string, string> typesMap = new()
        {
            { "Int16", "short" },
            { "Int32", "int" },
            { "Int64", "long" },
            { "UInt16", "ushort" },
            { "Unt32", "uint" },
            { "UInt64", "ulong" },
            { "Single", "float" },
            { "Double", "double" },
            { "Decimal", "decimal" },
            { "String", "string" },
            { "Boolean", "bool" }
        };

}
